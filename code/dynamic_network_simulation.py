# -*- coding: utf-8 -*-
"""dynamic_credit_networks.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1B54DJ_uhbFqW-rbIzP8ijCc2A700cnNQ
"""

import itertools
from itertools import combinations, chain

import numpy as np
import cvxpy as cp
 
def findsubsets(s, n):
    return list((map(frozenset, itertools.combinations(s, n))))


def powerset(iterable):
    "powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))


def max_credit_issue(belief_array,credit_limit):

  credit_issue_var = cp.Variable(belief_array.shape[0])

  ##print ("belief_array",belief_array,belief_array.shape[0])
  constraints = [credit_issue_var>=0,cp.sum(credit_issue_var)<=credit_limit]

  positive_utility = cp.sum(2*cp.power((credit_issue_var+1),0.5)-2)

  prob = cp.Problem(cp.Maximize(positive_utility-credit_issue_var@(1-belief_array)),constraints)

  prob.solve()

  return credit_issue_var.value

def gamma_decr(round): ###decreasing with round

  return 1.0/((round+1)**0.2)

no_neighs = 3

belief_array = np.array([0,0.7,0.9])
credit_limit = 10
print (max_credit_issue(belief_array,credit_limit))

import numpy as np
import csv
from datetime import datetime

"""Relevant Constants:


*   **μ ~ Uni[0,1]:** constant to partition agents into Trustworthy (μ⋅*V*) or Untrustworthy Agents ((1-μ) ⋅*V*)
*  **overall_beliefs:** belief of trustworthiness of node *u* about all nodes *V* in graph *G(i)* at round *i* 
* **rounds:** number of rounds in the game
* **filename**: path to file with list of agents




"""

default_prob = 0.3

# mu = np.random.uniform()
overall_beliefs = {} # dictionary agent: list of floats
beta = 0.3
alpha = 0.1

num_rounds = 400
num_agents = 40 # for testing purposes
# mu = np.random.randint(1,num_agents)/num_agents
# uncomment below to generate plot with desired mu value.
# mu = 0.25
# mu = 0.5
mu = 0.75
print (mu)
now = datetime.now() # current date and time
filename = "agents_" + now.strftime("%m-%d-%Y_%H:%M:%S") + ".csv" # change to agents + curr_date.csv

with open(filename, 'w') as f:
    np.random.seed(17)
    # create the csv writer
    fieldnames = ["trustworthiness", "credit_limit"]
    writer = csv.DictWriter(f, fieldnames=fieldnames)

    writer.writeheader()

    for itr in range(num_agents):
      # determine if agent is trustworthy
      # want T = mu * V and U = (1-mu) * V
      if (itr < mu*num_agents):
        trustworthiness = 1
      else:
         trustworthiness = 0
      credit_limit = np.random.randint(0, 100)

      # write agent to the csv file
      writer.writerow({fieldnames[0] : trustworthiness, fieldnames[1] : credit_limit})

"""Information about Agent *u*:


*   **trustworthiness**= 1 if trustworthy, else **trustworthiness** = 0
*   **credit_limit** ∈ ℕ: credit issuing limit of node *u* 
*   **neighbors**: neighbors of *u* at round *i*
*   **beliefs**: belief of trustworthiness of node *u* about node *v* at round *i*
*   **credit_extended**: credit extended to node *v* by node *u* at round *i*
*   **IOUs**: IOU’s that node *u* owes node *v* at round *i*

"""

class Agent:
  def __init__(self, t, c, default_prob, identity): ##neigh used for initilising set of neighbours
    self.trustworthiness = t
    self.credit_limit = c
    self.neighbors = set() # probably want this to initially be all other nodes and let it dwindle down ??
    self.beliefs = {}
    self.credit_extended = {}
    self.IOUs = {}
    self.default_prob = default_prob
    self.identifier = identity


    ##self.total_transaction = 0
    ##self.transaction = {}

"""Establish **credit_network = (agents, ties)**


1.   Define trustworthy and untrustworthy agents
2.   Keep track of history of transactions: 
    * **transactions**: node *u* honours IOU to node *v* at round *i*

initialize agents with their trustworthiness and their defined credit limit \\
-> are ties existing initially or should that be done at random in the first round???
"""

def process_agents(filename):
  agents = []
  with open(filename, 'r') as file:
    csvreader = csv.reader(file)
    header = next(csvreader)
    count = 0
    for row in csvreader:
        agent = Agent(t=int(row[0]), c=int(row[1]), default_prob=default_prob, identity=count)
        agents.append(agent)
        count += 1

  file.close()

  agent.beliefs = {}

  ##hat_mu = np.random.uniform(0,1)
  hat_mu = 0.5

  print ("Initial beliefs",hat_mu)
  
  for agent in agents:
    agent.neighbors = [a for a in agents if a != agent]
    # agent.beliefs[agent] = [mu for a in agents if a != agent] ###initial beliefs
    agent.beliefs = {a : hat_mu for a in agents if a != agent}
    overall_beliefs[agent] = np.zeros(num_rounds)

  return agents #list of Agent objects

agents = process_agents(filename)


ties = {agent: {neighbor : 0 for neighbor in agents if neighbor != agent} for agent in agents} # dictionary (agent -> dictionary (agent -> int that is initially 0))
print ("ties",ties)

credit_network = (agents, ties)

# history of defaults and transactions for each agent in each round
transactions = [{agent: {neighbor : 0 for neighbor in agent.neighbors} for agent in agents} for _ in range(num_rounds)] # list of dictionaries, index i represents IOUs exchanged in round i
defaults = [{agent: {neighbor : 0 for neighbor in agent.neighbors} for agent in agents} for _ in range(num_rounds)] # list of dictionaries, index i represents who defaulted on round i

"""**Assigning Trust** \\
*Assumptions*: each neighbor in trustworthy. \\
For each agent, we establish how much credit we want to extend to each neighbor. If we extend credit, we can establish a tie for agent to its neighbor in our graph. Then, we record the IOUs exchanged between agent and its neighbor.

sum of credit issued amongst all neighbors is bounded by credit_limit

case where we issue most than we have, convex minimizations -> software cvxpy
"""

def assign_trust(agents):
  IOUs_exchanged = {}
  ##transactions_no_dict = {}
  for agent in agents:
    
    ##print ("Belief inside",agent.beliefs)
    belief_array = np.array([agent.beliefs[neigh] for neigh in agent.beliefs]).flatten()

    ##print ("Belief array",belief_array,type(belief_array),belief_array.shape)
    ###transaction_temp_dict = {}
    for neigh in agents:
      if (neigh != agent):
        IOUs_exchanged[(agent,neigh)] = 0 ###initialising all IOUs excahnge by 0

    credit_assn_array = max_credit_issue(belief_array,agent.credit_limit)
    
    for index in range(len(agent.beliefs.keys())): ###basically all neighbours

      neighbor = list(agent.beliefs.keys())[index]
      ##assigned_credit = np.random_integers(0, agent.credit_limit) #CHANGE: want to maximize by add some randomness
      assigned_credit = credit_assn_array[index]
      ##print ("ties",ties)
      if (assigned_credit != 0): 
        ties[agent][neighbor] = 1 # establish a tie between agent u and its neighbor agent v
        ##transaction_temp_dict[neighbor] = 1
      else: 
        ties[agent][neighbor] = 0 # TODO: should we remove the neighbor from our list if we don't extend credit to them?
        ##transaction_temp_dict[neighbor] = 0
      IOUs_exchanged[(agent,neighbor)] = assigned_credit*beta
      ##transaction_temp_dict[neighbor] = 1
    ##transactions_dict[agent] = transaction_temp_dict

    

  
  
  return IOUs_exchanged

def to_default_not():

  

  pass

"""deciding to default
  if you are untrustworthy \\
    1. flip a coin; heads = default, tails = honor
    2. default with probability overall_beliefs[agent]
    3. default with probability overall_beliefs[agent] and maximize gain (default on person w highest credit issued)
"""

def reclaim_IOUs(agents, IOUs_exchanged):
  defaults = {}
  for agent,neighbor in IOUs_exchanged: 
    ##for neighbor in neighbors:
      # if agent defaults on the IOU to its neighbor, record 1 else 0
      if (agent.trustworthiness) : # if agent is trustworthy, always honour transaction
        defaults[(agent,neighbor)] = 0
      elif (IOUs_exchanged[(agent,neighbor)] >= IOUs_exchanged[(neighbor,agent)] or IOUs_exchanged[(neighbor,agent)] <=1e-7): ###agent has paid more than it is owed so no default
        defaults[(agent,neighbor)] = 0

      else:
        total_IOUs_owed = sum([max(-IOUs_exchanged[(agent,neighbor)] + IOUs_exchanged[(neighbor,agent)],0) for neighbor in agents if neighbor != agent]) ##considering those neighbours whom it owes IOUs

        ##print ("total IOUs owed by",agent.identifier, " is ",total_IOUs_owed)
        ##defaults[(agent,neighbor)] = np.random.uniform(0,agent.default)

        temp = np.random.uniform()

        # defaulting is contingent on whether the gain from
        # defaulting on the previous transactions of round i 
        # is greater than the future expected (marginal)
        # utility of maintaining a tie with neighbor v





        ##default_gain, expected_tie_gain = calculate_gain()
        if (temp<agent.default_prob*(-IOUs_exchanged[(agent,neighbor)] + IOUs_exchanged[(neighbor,agent)])/total_IOUs_owed): ###probability of defaulting by an agent
          defaults[(agent,neighbor)] = 1
          ###print ("Agent",agent.identifier,"defaulted to",neighbor.identifier)
        else: defaults[(agent,neighbor)] = 0
  return defaults

np.random.uniform(0,0.3)

dict = {}
dict[(1,2)] = 7
for i,j in dict:
  print (i)

"""updating beliefs:

  - if someone defaults, we never want to extend credit to them again

  thought:
```
if (defaults[agent][neighbor]): 
  agent.neighbors.remove(neighbor)
  ties[agent][neighbor] = 0
```



"""

np.average(np.array([1,2,5]))

from numpy.random.mtrand import gamma
def update_beliefs(round):
  # need to update beliefs about each neighbor and overall belief about V

  # overall_beliefs = {}
  belief_individual = {} 
  for agent in agents:
    
    
    

    ###net_transactions_no = len(transactions[round][agent])

    """

    net_transactions_no = 0 ###counting number of transactions till round t
    net_default_no = 0
    for itr in range(round):
     for i in transactions[round]:
      if agent == i[0] and transactions[round][i] > 0:
        net_transactions_no += 1
     for j in defaults[round]:
       if agent == j[1] and defaults[round][j] == 1:
        net_default_no += 1
    """

    overall_beliefs[agent][round] = np.average([agent.beliefs[neighbour] for neighbour in agents if neighbour != agent])


    ##overall_beliefs[agent][round] = ((mu+alpha*(net_transactions_no-net_default_no))/(1+alpha*(net_transactions_no)) ) ###weight to initial belief and weight to the number of transactions successfully completed.
    ####no of trustworthy transactions###

    if (overall_beliefs[agent][round]<-1e-10):
      print ("Beliefs",overall_beliefs[agent][round])

    ##print ("Overall beliefs",overall_beliefs)
    belief_individual_temp = {}
    for neighbor in agents:
      if (neighbor != agent):
  
        if (not (np.all([not defaults[itr][(neighbor,agent)]for itr in range(round+1)]))):
          if (neighbor in agent.neighbors): 
            agent.neighbors.remove(neighbor)
          ties[agent][neighbor] = 0
          ties[neighbor][agent] = 0


          belief_individual_temp[neighbor] = 0

        else: 
          belief_individual_temp[neighbor] = (gamma_decr(round))*overall_beliefs[agent][round] + 1-gamma_decr(round)

          ###print ("Computed val",(gamma_decr(round))*overall_beliefs[agent] + 1-gamma_decr(round),"gamma_decr",gamma_decr(round),"overall belief",overall_beliefs[agent])
    belief_individual[agent] = belief_individual_temp
    # agent.beliefs = belief_individual_temp

    ##print ("belief_individual_temp",belief_individual_temp)

    
  return belief_individual







  pass

a = [True,False,False]
np.all(a)

"""TODO: decide what relevant information we want to extract from the game"""

import random

def get_random_color():
  random_number = random.randint(0,16777215) 
  hex_number = str(hex(random_number)) 
  hex_number ='#'+ hex_number[2:]
  return hex_number

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import numpy as np
import matplotlib.pyplot as plt
plt.style.use('seaborn-whitegrid')

def get_plot(x, y, title):
  plt.scatter(x, y)
  plt.plot(x, y)
  plt.title(title)
  plt.show()

def plot_game_summary():
  fig = plt.figure()
  ax = plt.axes()
  
  # plt.plot([i for i in range(num_rounds)], [i for i in reversed(range(num_rounds))])
  for agent in agents:
    x = [i for i in range(num_rounds)]
    y = overall_beliefs[agent]
    # color = get_random_color()
    # lw = random.uniform(0,5)
    get_plot(x,y,"agent " + str(agent.identifier) + ": OVERALL BELIEFS")

"""https://towardsdatascience.com/graph-visualisation-basics-with-python-part-ii-directed-graph-with-networkx-5c1cd5564daa """

def print_game_statistics():
  s = "\n *"
  for i in range(50): s += "*"
  s+= "\n"
  print(s)
  print("Number of players: ", num_agents)
  print("Number of Rounds: ", num_rounds)


  print("plotting overall beliefs")
  plot_game_summary()

from networkx.algorithms.boundary import node_boundary
def plot_individual_beliefs(agent, agent_belief_history):

  # agent_labels = {}
  # i = 0
  # for a in agents:
  #   agent_labels[a] = i
  #   i+=1

  title = "agent " + str(agent.identifier) + ": INDIVIDUAL"
  x = [i for i in range(num_rounds)]

  y = {}
  for a in agents:
    if a == agent: continue
    y[a] = np.zeros(num_rounds)

  for round, round_beliefs in enumerate(agent_belief_history):

    for n in round_beliefs.keys():
      # print(round_beliefs[n])
      # np.append(y[n], round_beliefs[n])
      y[n][round] = round_beliefs[n]
      # y[n] = round_beliefs[n]

  for i, n in enumerate(y.keys()):
    plt.scatter(x, y[n])
    plt.plot(x, y[n], label = "agent " + str(n.identifier))
    if i % 5 == 0 and i != 0:
        plt.legend()
        plt.title(title)
        plt.show()

  plt.legend()
  plt.title(title)
  plt.show()


def plot_beliefs_bw_agents(history_of_indiv_beliefs):
  i = 0
  nodes = len(agents)
  for agent in history_of_indiv_beliefs.keys():
    agent_belief_history = history_of_indiv_beliefs[agent]
    plot_individual_beliefs(agent, agent_belief_history)

    if (np.random.uniform() >= 0.5): limited_individual_beliefs_plot(agent, agent_belief_history)

    num_neighbors = len(agent_belief_history[0].keys())
    print("NUM NEIGHBORS FOR AGENT ", i)
    print(str(num_neighbors))
    i+=1

def limited_individual_beliefs_plot(agent, agent_belief_history):

  # agent_labels = {}
  # i = 0
  # for a in agents:
  #   agent_labels[a] = i
  #   i+=1


  title = "agent " + str(agent.identifier) + ": INDIVIDUAL (ONLY 1 TRUSTWORTHY)"
  x = [i for i in range(num_rounds)]

  y = {}
  for a in agents:
    if a == agent: continue
    y[a] = np.zeros(num_rounds)

  for round, round_beliefs in enumerate(agent_belief_history):

    for n in round_beliefs.keys():
      # print(round_beliefs[n])
      # np.append(y[n], round_beliefs[n])
      y[n][round] = round_beliefs[n]
      # y[n] = round_beliefs[n]

  if (agent.identifier == 7):
    # print("HERE")
    for i, n in enumerate(y.keys()):
      title = "AGENT " + str(agent.identifier) + " DEEP DIVE w AGENT " + str(n.identifier)
      get_plot(x, y[n], title)
    return
  else:
    print("SKIP " + str(agent.identifier))

  contains_trustworthy_agent = 0
  for i, n in enumerate(y.keys()):
    if n.trustworthiness == 1 and contains_trustworthy_agent == 0: contains_trustworthy_agent = 1
    elif n.trustworthiness == 1 and contains_trustworthy_agent == 1: continue
    plt.scatter(x[0:150], y[n][0:150])
    plt.plot(x[0:150], y[n][0:150], label = "agent " + str(n.identifier)) ##modif to see important part
    if (i + 1) % 5 == 0:
      contains_trustworthy_agent = 0
      plt.legend()
      plt.title(title)
      plt.show()

  plt.legend()
  plt.title(title)
  plt.show()

history_of_indiv_beliefs = {}

  # dictionary {agent : [dictionary {neighbor : agent.beliefs[neighbor] for neighbor in agents if neighbor != agent} for _ in num_rounds]}
  # key: agent, val: list of agent beliefs for all neighbors for all rounds
for agent in agents:
  history_of_indiv_beliefs[agent] = []

# num_rounds = 40
def play_game():

  for round in range(num_rounds):

    ##print ("round",round)
    
    # step 0
    IOUs_exchanged = assign_trust(agents)
    transactions[round] = IOUs_exchanged

    # step 1
    defaults[round] = reclaim_IOUs(agents, IOUs_exchanged)
    ##update_beliefs(agents, overall_beliefs)
    curr_belief = update_beliefs(round)

    for agent in agents:
      agent.beliefs= curr_belief[agent]
      history_of_indiv_beliefs[agent].append(agent.beliefs)
    ##print ("curr_belief after round",round,curr_belief)
    
  
  print_game_statistics()
  # plot_beliefs_bw_agents(history_of_indiv_beliefs)
  return curr_belief

final_belief = play_game()

for agent in final_belief:
  belief_ind = final_belief[agent]
  if (agent.trustworthiness == 0):
    ##for neigh in belief_ind:
      ##if (neigh.t == 0):
        print ("Trust by untrustorthy agent",agent.identifier," on ", "credit_limit",agent.credit_limit, [(neigh.identifier,neigh.trustworthiness,belief_ind[neigh]) for neigh in belief_ind])
  else:
        print ("Trust by trustorthy agent",agent.identifier," on ", "credit_limit",agent.credit_limit, [(neigh.identifier,neigh.trustworthiness,belief_ind[neigh]) for neigh in belief_ind])
     
print (play_game)

for agent in agents:
  if (agent.identifier == 9): ##node issuing low credit
    limited_individual_beliefs_plot(agent,history_of_indiv_beliefs[agent])
  if (agent.identifier == 1): 
    limited_individual_beliefs_plot(agent,history_of_indiv_beliefs[agent])

import matplotlib.pyplot as plt

def plot_percentiles(low, mid, high):

  d = [(agent, agent.credit_limit) for agent in agents]

  d.sort(key=lambda y: y[1])

  credit_limits = [agent.credit_limit for agent in agents]

  x = [i for i in range(num_rounds)]


  low_q = low # set to whatever "low" percentile, np.percentile returns the q-th percentile(s) of the array elements.
  mid_q = mid
  high_q = high

  low_q_percentile = np.percentile(credit_limits, low_q)
  high_q_percentile = np.percentile(credit_limits, high_q)
  mid_q_percentile = np.percentile(credit_limits, mid_q)

  print(low_q_percentile, high_q_percentile, mid_q_percentile)

  p = [low_q_percentile, high_q_percentile, mid_q_percentile]


  larr = []
  harr = []
  marr = []

  for a, c in d:
    if c <= low_q_percentile:
      larr.append(a)
    elif c <= mid_q_percentile:
      marr.append(a)
    elif c <= high_q_percentile:
      harr.append(a)

  hbeliefs = np.zeros(num_rounds)
  for a in harr:
    for r in range(num_rounds):
      hbeliefs[r] += overall_beliefs[a][r]

  for i in range(len(hbeliefs)):
    hbeliefs[i] /= len(harr)

  lbeliefs = np.zeros(num_rounds)
  for a in larr:
    for r in range(num_rounds):
      lbeliefs[r] += overall_beliefs[a][r]

  for i in range(len(lbeliefs)):
    lbeliefs[i] /= len(larr)

  mbeliefs = np.zeros(num_rounds)
  for a in marr:
    for r in range(num_rounds):
      mbeliefs[r] += overall_beliefs[a][r]

  for i in range(len(mbeliefs)):
    mbeliefs[i] /= len(marr)

  plt.scatter(x, lbeliefs)
  plt.plot(x, lbeliefs, label = "Low percentile")

  plt.scatter(x, mbeliefs)
  plt.plot(x, mbeliefs, label = "Middle percentile")

  plt.scatter(x, hbeliefs)
  plt.plot(x, hbeliefs, label = "High percentile")

  plt.ylim(0.2, 1)


  plt.title("MU = " + str(mu))
  plt.legend()
  plt.savefig("mu="+ str(mu) + ".png")
  plt.show()

plot_percentiles(33, 66, 99)

x = [i for i in range(num_rounds)]
a1 = agents[0]
a2 = agents[0]
for agent in agents: 
  if agent.identifier == 23:
    a1 = agent
  elif agent.identifier == 1:
    a2 = agent
  else:
    continue

y = [overall_beliefs[a1][round] for round in range(num_rounds)]
plt.scatter(x,y)
plt.plot (x,y,label = "Global belief of agent 9")

y = [overall_beliefs[a2][round] for round in range(num_rounds)]
plt.scatter(x,y)
plt.plot (x,y,label = "Global belief of agent 1")

plt.legend()
plt.title("TEST")
plt.show()

# # !pip install netgraph
# # !sudo apt-get install graphviz graphviz-dev
# # !pip install pygraphviz
# import networkx as nx
# from netgraph import Graph
# import pygraphviz as pgv
# from networkx.drawing import nx_pydot
# from graphviz import Source

# def weighted_graph():
#   pass
#   G = nx.MultiDiGraph()

#   nodes = np.arange(0, len(agents)).tolist()
  
#   G.add_nodes_from(nodes)

#   edges = []

#   for i in range(len(agents)):
#     for j in range(len(agents)):
#       if i != j: edges.append((i,j))

#   # G = pgv.AGraph(directed=True, strict=True, rankdir="LR")

#   agent_labels = {}
#   i = 0
#   for agent in agents:
#     agent_labels[i] = agent
#     i+=1
  
#   # for agent in agents:
#   #   for n in agents:
#   #     if agent == n: continue
#   #     G.add_edge(agent_labels[agent], agent_labels[n])
#   #     # pass
      
  
#   G.add_edges_from(edges)

#   edge_labels = {}

#   for e in edges:
#     agent = agent_labels[e[0]]
#     neighbor = agent_labels[e[1]]
#     edge_labels[e] = str('%.4f' % agent.beliefs[neighbor])


#   labels = {i : "agent " + str(i) for i in range(len(agents))}

#   pos = nx.spring_layout(G, k=0.2*1/np.sqrt(len(G.nodes())), iterations=20)

#   # nx.draw_networkx(G, labels = labels, 
#   #                  arrows = True, 
#   #                  node_size = 1000)
#   # nx.draw_networkx_edge_labels(G, pos = pos,
#   #                            edge_labels = edge_labels)
#   # plt.figure(figsize=(20 , 20))
#   # netgraph.draw(G, labels = labels, arrows = True, node_size=1000)

#   # plt.show()

#   # plt.show()
#   nx_pydot.write_dot(G, 'multig.dot')
#   A = pgv.AGraph("multig.dot")
#   A.layout("dot")
#   A.draw("foo.png")
#   # Source.from_file('multig.dot')


#   # G = nx.DiGraph()

#   # G.add_edge('1','2')
#   # G.add_edge('1','3')
#   # G.add_edge('3','2')
#   # G.add_edge('3','4')
#   # G.add_edge('4','3')

#   # plot_instance = Graph(G, node_color='w', edge_color='k', edge_width=2.0, node_labels=labels)
 

#   # # plot_instance = Graph(
#   # #   G, node_size=5,
#   # #   node_labels=True, node_label_offset=0.1, node_label_fontdict=dict(size=20),
#   # #   edge_width=2,
#   # #   arrows=True)
#   # plt.show()


#   # G.add_nodes_from(agent_labels.values())
#   # # G.add_edges_from(edges)

#   # G.graph_attr["epsilon"] = "0.01"
#   # print(G.string())
#   # G.layout("dot")
#   # G.draw("foo.png")

# # weighted_graph()

d = {1:3,4:6}
ar = np.asarray(d.values())
print (list(d.keys())[1])
len(d)

a = np.array([4])
print (a)
a.shape

# import matplotlib.pyplot as plt
# import networkx as nx

# def weighted_graph(round):

#   print("GRAPH OF INDIVIDUAL BELIEFS: ROUND ", round)

#   G = nx.Graph()

#   agent_labels = {}
#   i = 0
#   for agent in agents:
#     agent_labels[str(i)] = agent
#     i+=1
  
#   edges = []

#   for i in range(len(agents)):
#     for j in range(len(agents)):
#       if i != j: edges.append((str(i),str(j)))

#   for e in edges:
#     agent = agent_labels[e[0]]
#     neighbor = agent_labels[e[1]]
#     edge_label = str('%.4f' % agent.beliefs[neighbor])
#     G.add_edge(e[0], e[1], weight = float(edge_label))

#   elarge = [(u, v) for (u, v, d) in G.edges(data=True) if d["weight"] > 0.5]
#   esmall = [(u, v) for (u, v, d) in G.edges(data=True) if d["weight"] <= 0.5]

#   pos = nx.spring_layout(G, seed=len(agents), k=0.5)  # positions for all nodes - seed for reproducibility

#   # nodes
#   nx.draw_networkx_nodes(G, pos, node_size=700)

#   # edges
#   nx.draw_networkx_edges(G, pos, edgelist=elarge, width=6)
#   nx.draw_networkx_edges(
#       G, pos, edgelist=esmall, width=6, alpha=0.5, edge_color="b", style="dashed"
#   )
  
#   plt.figure(figsize=(10,6))
#   # node labels
#   nx.draw_networkx_labels(G, pos, font_size=20, font_family="sans-serif")
#   # edge weight labels
#   edge_labels = nx.get_edge_attributes(G, "weight")
#   nx.draw_networkx_edge_labels(G, pos, edge_labels)

#   ax = plt.gca()
#   ax.margins(0.08)
#   plt.axis("off")
  
#   plt.title("ROUND " + str(round))
#   plt.tight_layout()
#   plt.show()

#   # nodes = np.arange(0, len(agents)).tolist()

#   # G.add_nodes_from(nodes)

import networkx as nx
from networkx.drawing.nx_pydot import write_dot

def get_change(round, curr_beliefs, prev_beliefs, neighbor):
  prev_mu = prev_beliefs[neighbor]
  curr_mu = curr_beliefs[neighbor]

  if curr_mu > prev_mu:
    return True, False
  elif curr_mu < prev_mu:
    return False, True
  else: 
    return False, False

def graph_belief_changes(round, history_of_indiv_beliefs):

  print("GRAPH OF INDIVIDUAL BELIEFS: ROUND ", round)

  G = nx.MultiGraph()

  agent_labels = {}
  labels = {}
  i = 0
  for agent in agents:
    agent_labels[i] = agent
    labels[i] = str(i)
    i+=1
  
  nodes = np.arange(0, len(agents)).tolist()
  
  G.add_nodes_from(nodes)

  # inc_edges = []
  # dec_edges = []
  # no_change_edges = []
  edges = []
  edge_colors = []

  for i in range(len(agents)):
    for j in range(len(agents)):
      if i != j: 
        agent = agent_labels[i]
        neighbor = agent_labels[j]
        if round > 0:
          inc, dec = get_change(round, history_of_indiv_beliefs[agent][round], 
                           history_of_indiv_beliefs[agent][round - 1], neighbor)
          if inc: edge_colors.append("green")
          elif dec: edge_colors.append("red")
          else: edge_colors.append("grey")
        else:
          edge_colors.append("grey")
        edges.append((i,j))


  G.add_edges_from(edges)

  pos = nx.spring_layout(G, seed=len(agents), k=0.5)  # positions for all nodes - seed for reproducibility

  nx.draw(G, pos = pos, arrows = True, edge_color = edge_colors, 
          connectionstyle='arc3, rad = 0.1', labels=labels, node_color = "skyblue")

  # write_dot(G,'multi.dot')
  # !neato -T png multi.dot > multi.png
  
  # plt.figure(figsize=(10,6))

  # ax = plt.gca()
  # ax.margins(0.08)
  # plt.axis("off")
  
  plt.title("ROUND " + str(round))
  # plt.tight_layout()
  plt.show()

  # nodes = np.arange(0, len(agents)).tolist()

  # G.add_nodes_from(nodes)
